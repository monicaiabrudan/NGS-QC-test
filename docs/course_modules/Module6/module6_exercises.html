<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Exercises – NGS Bioinformatics course</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">NGS Bioinformatics course</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-modules" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Modules</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-modules">    
        <li>
    <a class="dropdown-item" href="../../course_modules/Module1/module1.html">
 <span class="dropdown-text">File formats</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course_modules/Module2/module2.html">
 <span class="dropdown-text">Reads alignment</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course_modules/Module3/module3.html">
 <span class="dropdown-text">Variant calling</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course_modules/Module4/module4.html">
 <span class="dropdown-text">Structural Variation Calling</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course_modules/Module5/module5.html">
 <span class="dropdown-text">Genome assembly</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course_modules/Module6/module6.html">
 <span class="dropdown-text">RNA-seq</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course_modules/Module7/module7.html">
 <span class="dropdown-text">CHiP-Seq</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#rna-seq-expression-analysis" id="toc-rna-seq-expression-analysis" class="nav-link active" data-scroll-target="#rna-seq-expression-analysis">1 RNA-Seq expression analysis</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">1.1 Introduction</a></li>
  <li><a href="#learning-outcomes" id="toc-learning-outcomes" class="nav-link" data-scroll-target="#learning-outcomes">1.2 Learning outcomes</a></li>
  <li><a href="#tutorial-sections" id="toc-tutorial-sections" class="nav-link" data-scroll-target="#tutorial-sections">1.3 Tutorial sections</a></li>
  <li><a href="#authors" id="toc-authors" class="nav-link" data-scroll-target="#authors">1.4 Authors</a></li>
  <li><a href="#prerequisites" id="toc-prerequisites" class="nav-link" data-scroll-target="#prerequisites">1.5 Prerequisites</a></li>
  <li><a href="#where-can-i-find-the-tutorial-data" id="toc-where-can-i-find-the-tutorial-data" class="nav-link" data-scroll-target="#where-can-i-find-the-tutorial-data">1.6 Where can I find the tutorial data?</a></li>
  </ul></li>
  <li><a href="#introducing-the-tutorial-dataset" id="toc-introducing-the-tutorial-dataset" class="nav-link" data-scroll-target="#introducing-the-tutorial-dataset">2 Introducing the tutorial dataset</a>
  <ul class="collapse">
  <li><a href="#section" id="toc-section" class="nav-link" data-scroll-target="#section"></a></li>
  <li><a href="#exercise-1" id="toc-exercise-1" class="nav-link" data-scroll-target="#exercise-1">2.2 Exercise 1</a></li>
  <li><a href="#questions" id="toc-questions" class="nav-link" data-scroll-target="#questions">2.3 Questions</a></li>
  </ul></li>
  <li><a href="#mapping-rna-seq-reads-to-the-genome-using-hisat2" id="toc-mapping-rna-seq-reads-to-the-genome-using-hisat2" class="nav-link" data-scroll-target="#mapping-rna-seq-reads-to-the-genome-using-hisat2">3 Mapping RNA-Seq reads to the genome using HISAT2</a>
  <ul class="collapse">
  <li><a href="#introduction-1" id="toc-introduction-1" class="nav-link" data-scroll-target="#introduction-1">3.1 Introduction</a></li>
  <li><a href="#mapping-rna-seq-reads-to-a-genome" id="toc-mapping-rna-seq-reads-to-a-genome" class="nav-link" data-scroll-target="#mapping-rna-seq-reads-to-a-genome">3.1.1 Mapping RNA-Seq reads to a genome</a></li>
  <li><a href="#exercise-2" id="toc-exercise-2" class="nav-link" data-scroll-target="#exercise-2">3.2 Exercise 2</a></li>
  <li><a href="#questions-1" id="toc-questions-1" class="nav-link" data-scroll-target="#questions-1">3.3 Questions</a></li>
  </ul></li>
  <li><a href="#visualising-transcriptomes-with-igv" id="toc-visualising-transcriptomes-with-igv" class="nav-link" data-scroll-target="#visualising-transcriptomes-with-igv">4 Visualising transcriptomes with IGV</a>
  <ul class="collapse">
  <li><a href="#introduction-2" id="toc-introduction-2" class="nav-link" data-scroll-target="#introduction-2">4.1 Introduction</a></li>
  <li><a href="#exercise-3" id="toc-exercise-3" class="nav-link" data-scroll-target="#exercise-3">4.2 Exercise 3</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Exercises</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="rna-seq-expression-analysis" class="level2">
<h2 class="anchored" data-anchor-id="rna-seq-expression-analysis">1 RNA-Seq expression analysis</h2>
<section id="introduction" class="level3">
<h3 class="anchored" data-anchor-id="introduction">1.1 Introduction</h3>
<p>RNA sequencing (RNA-Seq) is a high-throughput method used to profile the transcriptome, quantify gene expression and discover novel RNA molecules. This tutorial uses RNA sequencing of malaria parasites to walk you through transcriptome visualisation, performing simple quality control checks and will show you how to profile transcriptomic differences by identifying differentially expressed genes.</p>
<p>For an introduction to RNA-Seq principles and best practices see:</p>
<p>A survey of best practices for RNA-Seq data analysis, Ana Conesa, Pedro Madrigal, Sonia Tarazona, David Gomez-Cabrero, Alejandra Cervera, Andrew McPherson, Michał Wojciech Szcześniak, Daniel J. Gaffney, Laura L. Elo, Xuegong Zhang and Ali Mortazavi, Genome Biol. 2016 Jan 26;17:13 doi:10.1186/s13059-016-0881-8</p>
</section>
<section id="learning-outcomes" class="level3">
<h3 class="anchored" data-anchor-id="learning-outcomes">1.2 Learning outcomes</h3>
<p>By the end of this tutorial you can expect to be able to:</p>
<p>• Align RNA-Seq reads to a reference genome and a transcriptome</p>
<p>• Visualise transcription data using standard tools</p>
<p>• Perform QC of NGS transcriptomic data</p>
<p>• Quantify the expression values of your transcripts using standard tools</p>
</section>
<section id="tutorial-sections" class="level3">
<h3 class="anchored" data-anchor-id="tutorial-sections">1.3 Tutorial sections</h3>
<p>This tutorial comprises the following sections:</p>
<p>1. Introducing the tutorial dataset</p>
<p>2. Mapping RNA-Seq reads to the genome with HISAT2</p>
<p>3. Visualising transcriptomes with IGV</p>
<p>4. Transcript quantification with Kallisto</p>
<p>5. Identifying differentially expressed genes with Sleuth</p>
<p>6. Interpreting the results</p>
<p>7. Key aspects of differential expression analysis</p>
</section>
<section id="authors" class="level3">
<h3 class="anchored" data-anchor-id="authors">1.4 Authors</h3>
<p>This tutorial was written by Victoria Offord based on materials from Adam Reid.</p>
<p>HISAT2 https://ccb.jhu.edu/software/hisat2/index.shtml 2.1.0</p>
<p>samtools https://github.com/samtools/samtools 1.10</p>
<p>IGV https://software.broadinstitute.org/software/igv/ 2.7.2</p>
<p>kallisto https://pachterlab.github.io/kallisto/download 0.46.2</p>
<p>R https://www.r-project.org/ 4.0.2</p>
<p>sleuth https://pachterlab.github.io/sleuth/download 0.30.0</p>
<p>bedtools http://bedtools.readthedocs.io/en/latest/content/installation.html 2.29.2</p>
</section>
<section id="prerequisites" class="level3">
<h3 class="anchored" data-anchor-id="prerequisites">1.5 Prerequisites</h3>
<p>This tutorial assumes that you have the following software or packages and their dependencies installed on your computer. The software or packages used in this tutorial may be updated from time to time so, we have also given you the version which was used when writing the tutorial.</p>
</section>
<section id="where-can-i-find-the-tutorial-data" class="level3">
<h3 class="anchored" data-anchor-id="where-can-i-find-the-tutorial-data">1.6 Where can I find the tutorial data?</h3>
<p>You can find the data for this tutorial by typing the following command in a new terminal window.</p>
<p><code>cd /home/manager/course_data/rna_seq</code></p>
<p>Now, let’s head to the first section of this tutorial which will be introducing the tutorial dataset.</p>
</section>
</section>
<section id="introducing-the-tutorial-dataset" class="level2">
<h2 class="anchored" data-anchor-id="introducing-the-tutorial-dataset">2 Introducing the tutorial dataset</h2>
<p>Working through this tutorial, you will investigate the effect of vector transmission on gene expression of the malaria parasite. The dataset you will be using for this tutorial and Figure 1 have been taken from the following publication:</p>
<p><em>Vector transmission regulates immune control of Plasmodium virulence,</em> Philip J. Spence, William Jarra, Prisca Lévy, Adam J. Reid, Lia Chappell, Thibaut Brugat, Mandy Sanders, Matthew Berriman and Jean Langhorne, Nature. 2013 Jun 13; 498(7453): 228–231 doi:10.1038/nature12231</p>
<p>Figure 1. Serial blood passage increases virulence of malaria parasites.</p>
<section id="section" class="level3">
<h3 class="anchored" data-anchor-id="section"></h3>
<p>2.1 Is the transcriptome of a mosquito-transmitted parasite different from one which has not passed through a mosquito?</p>
<p>The key reason for asking this question is that parasites which are transmitted by mosquito (MT) are less virulent (severe/harmful) than those which are serially blood passaged (SBP) in the laboratory.</p>
<p>Figure 1A shows the malaria life cycle, the red part highlighting the mosquito stage. Figure 1B shows the difference in virulence, measured by blood parasitemia (presence of parasites in the blood), between mosquito-transmitted and serially blood passaged parasites.</p>
<p>Figure 1C shows that increasing numbers of blood passage post mosquito transmission results in increasing virulence, back to around 20% parasitemia. Subsequent mosquito transmission of high virulence parasites render them low virulence again.</p>
<p>We hypothesise that parasites which have been through the mosquito are somehow better able to control the mosquito immune system than those which have not. This control of the immune system would result in lower parasitemia because this is advantageous for the parasite. Too high a parasitemia is bad for the mouse and therefore bad for the parasite.</p>
</section>
<section id="exercise-1" class="level3">
<h3 class="anchored" data-anchor-id="exercise-1">2.2 Exercise 1</h3>
<p>In this tutorial, you will be analysing five RNA samples, each of which has been sequenced on an Illumina HiSeq sequencing machine. There are two conditions: serially blood-passaged parasites (SBP) and mosquito transmitted parasites (MT). One with three biological replicates (SBP), one with two biological replicates (MT).</p>
<p>Sample name Experimental condition</p>
<p>Replicate number MT1 mosquito transmitted parasites 1</p>
<p>MT2 mosquito transmitted parasites 2</p>
<p>SBP1 serially blood-passaged parasites 1</p>
<p>SBP2 serially blood-passaged parasites 2</p>
<p>SBP3 serially blood-passaged parasites 3</p>
<p>Check that you can see the tutorial FASTQ files in the data directory.</p>
<p><code>ls data/*.fastq.gz</code></p>
<p>The FASTQ files contain the raw sequence reads for each sample. There are four lines per read:</p>
<p>1. Header</p>
<p>2. Sequence</p>
<p>3. Separator (usually a ‘+’)</p>
<p>4. Encoded quality value</p>
<p>Take a look at one of the FASTQ files.</p>
<p><code>zless data/MT1_1.fastq.gz | head</code></p>
<p>Find out more about FASTQ formats at https://en.wikipedia.org/wiki/FASTQ_format.</p>
</section>
<section id="questions" class="level3">
<h3 class="anchored" data-anchor-id="questions">2.3 Questions</h3>
<p>2.3.1 Q1: Why is there more than one FASTQ file per sample?</p>
<p>Hint: think about why there is a MT1_1.fastq.gz and a MT1_2.fastq.gz</p>
<p>2.3.2 Q2: How many reads were generated for the MT1 sample?</p>
<p>Hint: we want the total number of reads from both files (MT1_1.fastq.gz and MT1_2.fastq.gz) so perhaps think about the FASTQ format and the number of lines for each read or whether there’s anything you can use in the FASTQ header to search and count…</p>
<p>Now let’s move on to mapping RNA-Seq reads to the genome using HISAT2.</p>
</section>
</section>
<section id="mapping-rna-seq-reads-to-the-genome-using-hisat2" class="level2">
<h2 class="anchored" data-anchor-id="mapping-rna-seq-reads-to-the-genome-using-hisat2">3 Mapping RNA-Seq reads to the genome using HISAT2</h2>
<section id="introduction-1" class="level3">
<h3 class="anchored" data-anchor-id="introduction-1">3.1 Introduction</h3>
<p>For this exercise, we have reduced the number of reads in each sample to around 2.5 million to reduce the mapping time. However, this is sufficient to detect most differentially expressed genes.</p>
<p>The objectives of this part of the tutorial are:</p>
<p>• use HISAT2 to build an index from the reference genome</p>
<p>• use HISAT2 to map RNA-Seq reads to the reference genome</p>
</section>
<section id="mapping-rna-seq-reads-to-a-genome" class="level3">
<h3 class="anchored" data-anchor-id="mapping-rna-seq-reads-to-a-genome">3.1.1 Mapping RNA-Seq reads to a genome</h3>
<p>By this stage, you should have already performed a standard NGS quality control check on your reads to see whether there were any issues with the sample preparation or sequencing. In the interest of time, we won’t be doing that as part of this tutorial, but feel free to use the tools from earlier modules to give that a go later if you have time.</p>
<p>Next, we map our RNA-Seq reads to a reference genome to get context. This allows you to visually inspect your RNA-Seq data, identify contamination, novel exons and splice sites as well as giving you an overall feel for your transcriptome.</p>
<p>HISAT2 To map the RNA-Seq reads from our five samples to the reference genome, we will be using HISAT2, a fast and sensitive splice-aware aligner. HISAT2 compresses the genome using an indexing scheme based on the Burrows-Wheeler transform (BWT) and Ferragina-Manzini (FM) index to reduce the amount of space needed to store the genome. This also makes the genome quick to search, using a whole-genome FM index to anchor each alignment and then tens of thousands local FM indexes for very rapid extensions of these alignments.</p>
<p>For more information, and to find the original version of Figure 2, please see the HISAT paper:</p>
<p>HISAT: a fast spliced aligner with low memory requirements, Daehwan Kim, Ben Langmead and Steven L Salzberg, Nat Methods. 2015 Apr;12(4):357-60. doi:10.1038/nmeth.3317</p>
<p>HISAT2 is a splice-aware aligner which means it takes into account that when a read is mapped it may be split across multiple exons with (sometimes large) intronic gaps between aligned regions.</p>
<p>As you can see in Figure 2, HISAT2 splits read alignments into five classes based on the number of exons the read alignment is split across and the length of the anchor (longest continuously mapped portion of a split read):</p>
<p>• Aligns to a single exon (M)</p>
<p>• Alignment split across 2 exons with long anchors over 15bp (2M_gt_15)</p>
<p>• Alignment split across 2 exons with intermediate anchors between 8bp and 15bp (2M_8_15)</p>
<p>• Alignment split across 2 exons with short anchors less than 7bp (2M_1_7)</p>
<p>• Alignment split across more than 2 exons (gt_2M)</p>
<p>HISAT2 used the global index to place the longest continuously mapped portion of a read (anchor).</p>
<p>This information is then used to identify the relevant local index. In most cases, HISAT2 will only need to use a single local index to place the remaining portion of the read without having to search the rest of the genome.</p>
<p>For the human genome, HISAT2 will build a single global index and 48,000 local FM indexes. Each of the local indexes represents a 64kb genomic region. The majority of human introns are significantly shorter than 64kb, so &gt;90% of human introns fall into a single local index. Moreover, each of the local indexes overlaps its neighbour by ~1kb which means that it also has the ability to detect reads spanning multiple indexes.</p>
<p>Figure 2. Read types and their relative proportions from 20 million simulated 100-bp reads</p>
<p>There are five HISAT2 RNA-seq read mapping categories: (i) M, exonic read; (ii) 2M_gt_15, junction reads with long, &gt;15-bp anchors in both exons; (iii) 2M_8_15, junction reads with intermediate, 8- to 15-bp anchors; (iv) 2M_1_7, junction reads with short, 1- to 7-bp, anchors; and (v) gt_2M, junction reads spanning more than two exons (Figure 2A). Exoninc reads span only a single exon and represent over 60% of the read mappings in the 20 million 100-bp simulated read dataset.</p>
</section>
<section id="exercise-2" class="level3">
<h3 class="anchored" data-anchor-id="exercise-2">3.2 Exercise 2</h3>
<p>Be patient, each of the following steps will take a couple of minutes!</p>
<p>Look at the usage instructions for hisat2-build.</p>
<p><code>hisat2-build -h</code></p>
<p>This not only tells us the version of HISAT2 we’re using (essential for publication methods):</p>
<p>HISAT2 version 2.1.0 by Daehwan Kim (infphilo@gmail.com, http://www.ccb.jhu.edu/people/infphilo</p>
<p>But, that we also need to give histat2-build two pieces of information:</p>
<p>Usage: hisat2-build [options]* &lt;reference_in&gt; &lt;ht2_index_base&gt;</p>
<p>These are:</p>
<p>• &lt;reference_in&gt; location of our reference sequence file (PccAS_v3_genome.fa)</p>
<p>• &lt;ht2_index_base&gt; what we want to call our HISAT2 index files (PccAS_v3_hisat2.idx)</p>
<p>Build a HISAT2 index for our <em>Plasmodium chabaudi chabaudi AS (P. chabaudi)</em> reference genome using hisat2-build.</p>
<p><code>hisat2-build data/PccAS_v3_genome.fa data/PccAS_v3_hisat2.idx</code></p>
<p>You can see the generated index files using:</p>
<p><code>ls data/PccAS_v3_hisat2.idx*</code></p>
<p>Look at the usage for hisat2.</p>
<p><code>hisat2 -h</code></p>
<p>Here we can see that hisat2 needs several bits of information so that it can do the mapping:</p>
<p><code>hisat2 [options]* -x &lt;ht2-idx&gt; {-1 &lt;m1&gt; -2 &lt;m2&gt; | -U &lt;r&gt;} [-S &lt;sam&gt;]</code></p>
<p>• -x &lt;ht2-idx&gt; the prefix that we chose for our index files with hisat2-build (PccAS_v3_hisat2.idx)</p>
<p>• {-1 &lt;m1&gt; -2 &lt;m2&gt; | -U &lt;r&gt;} the left (-1) and right (-2) read files for the sample (MT1_1.fastq and MT1_2.fastq respectively</p>
<p>• [-S &lt;sam&gt;] the name of the file we want to write the output alignment to (MT1.sam) as, by default, hisat2 will print the results to the terminal (stdout)</p>
<p>We will also be adding one more piece of information, the maximum intron length (default 500,000 bases). For this analysis, we want to set the maximum intron length to 10,000. We can do this by adding the option –max-intronlen 10000.</p>
<p>Map the reads for the MT1 sample using HISAT2.</p>
<p><code>hisat2 --max-intronlen 10000 -x data/PccAS_v3_hisat2.idx -1 data/MT1_1.fastq.gz -2 data/MT1_2.fastq.gz -S data/MT1.sam</code></p>
<p>HISAT2 has written the alignment in SAM format. This is a format which allows humans to look at our alignments. However, we need to convert the SAM file to its binary version, a BAM file. We do this for several reasons. Mainly we do it because most downstream programs require our alignments to be in BAM format and not SAM format. However, we also do it because the BAM file is smaller and so takes up less (very precious!) storage space. For more information, see the format guide:</p>
<p><a href="http://samtools.github.io/hts-specs/SAMv1.pdf." class="uri">http://samtools.github.io/hts-specs/SAMv1.pdf.</a></p>
<p>Convert the SAM file to a BAM file.</p>
<p><code>samtools view -b -o data/MT1.bam data/MT1.sam</code></p>
<p>We now need to sort the BAM file ready for indexing. When we aligned our reads with HISAT2, alignments were produced in the same order as the sequences in our FASTQ files. To index the BAM file, we need the alignments ordered by their respective positions in the reference genome. We can do this using samtools sort to sort the alignments by their co-ordinates for each chromosome.</p>
<p>Sort the BAM file.</p>
<p><code>samtools sort -o data/MT1_sorted.bam data/MT1.bam</code></p>
<p>Next, we need to index our BAM file. This makes searching the alignments much more efficient.</p>
<p>It allows programs like IGV (which we will be using to visualise the alignment) to quickly get the alignments that overlap the genomic regions you’re looking at. We can do this with samtools index which will generate an index file with the extension .bai.</p>
<p>Index the BAM file so that it can be read efficiently by IGV.</p>
<p><code>samtools index data/MT1_sorted.bam</code></p>
<p>Now, repeat this process of mapping, converting (SAM to BAM), sorting and indexing with the reads from the MT2 sample. You can run the previous steps as a single command.</p>
<p><code>hisat2 –max-intronlen 10000 -x data/PccAS_v3_hisat2.idx -1 data/MT2_1.fastq.gz -2 data/MT2_2.fastq.gz | samtools view -b -| samtools sort -o data/MT2_sorted.bam - &amp;&amp; samtools index data/MT2_sorted.bam</code></p>
<p>Let’s not forget our SBP samples. We’ve already provided the BAM files for these samples.</p>
<p>Please check that you can see the BAM files before continuing.</p>
<p><code>ls -al data/SBP*.bam</code></p>
<p>You should see three files:</p>
<p>data/SBP1_sorted.bam</p>
<p>data/SBP2_sorted.bam</p>
<p>data/SBP3_sorted.bam</p>
<p>If you can’t see these files, please let your instructor know!!</p>
<p>We’ve previously shown you how to run HISAT2 and samtools with individual and one-line commands. For the SBP samples, a bash script was used to generate our genome alignments prior to this tutorial.</p>
<p>To take a look at the script you can run:</p>
<p><code>less data/map_SBP_samples.sh</code></p>
<p>If you have time at the end of the tutorial, feel free to take a closer look at the script and a more detailed breakdown of what it does in Running commands on multiple samples. Bash scripts and loops are a useful way of automating an analysis and running the same commands for multiple samples. Imagine if you had 50 samples and not 5! In truth, you’d probably want to run that many samples on a compute cluster, in parallel. But that’s outside the scope of this tutorial.</p>
</section>
<section id="questions-1" class="level3">
<h3 class="anchored" data-anchor-id="questions-1">3.3 Questions</h3>
<p><strong>3.3.1 Q1: How many index files were generated when you ran hisat2-build?</strong></p>
<p>Hint: look for the files with the .ht2 extension</p>
<p><strong>3.3.2 Q2: What was the overall alignment rate for each of the MT samples (MT1 and MT2) to the reference genome?</strong></p>
<p>Hint: look at the the output from the hisat2 commands</p>
<p><strong>3.3.3 Q3: How many MT1 and MT2 reads were not aligned to the reference genome?</strong></p>
<p>Hint: look at the the output from the hisat2 commands, you’re looking for reads (not read pairs) which have aligned 0 times (remember that one read from a pair may map even if the other doesn’t)</p>
</section>
</section>
<section id="visualising-transcriptomes-with-igv" class="level2">
<h2 class="anchored" data-anchor-id="visualising-transcriptomes-with-igv">4 Visualising transcriptomes with IGV</h2>
<section id="introduction-2" class="level3">
<h3 class="anchored" data-anchor-id="introduction-2">4.1 Introduction</h3>
<p>Integrative Genome Viewer (IGV) allows us to visualise genomic datasets. We have provided a quick start guide which contains the information you need to complete Exercise 3. There is also an IGV user guide online which contains more information on all of the IGV features and functions: <a href="http://software.broadinstitute.org/software/igv/UserGuide" class="uri">http://software.broadinstitute.org/software/igv/UserGuide</a>.</p>
<p>The objectives of this part of the tutorial are:</p>
<p>• load a reference genome into IGV and navigate the genome</p>
<p>• load an annotation file into IGV and explore gene structure</p>
<p>• load read alignments into IGV and inspect read alignments</p>
</section>
<section id="exercise-3" class="level3">
<h3 class="anchored" data-anchor-id="exercise-3">4.2 Exercise 3</h3>
<p>First, we will use samtools to create an index for the P. chabaudi reference genome, which IGV will use to traverse the genome. This index file will have the extension .fai and should always be in the same directory as the reference genome.</p>
<p>First, index the genome fasta file (required by IGV).</p>
<p><code>samtools faidx data/PccAS_v3_genome.fa</code></p>
<p>Now, start IGV.</p>
<p><code>igv &amp;</code></p>
<p>This will open the IGV main window. Now, we need to tell IGV which genome we want to use. IGV has many pre-loaded genomes available, but P. chabaudi is not one of them. This means we will need to load our genome from a file.</p>
<p>Load your reference genome into IGV. Go to “Genomes -&gt; Load Genome from File…”. Select “PccAS_v3_genome.fa” and click “Open”. For more information, see Loading a reference genome in our quick start guide.</p>
<p>We not only want to see where our reads have mapped, but what genes they have mapped to. For this, we have an annotation file in GFF3 format. This contains a list of features, their co-ordinates and orientations which correspond to our reference genome.</p>
<p>Example from PccAS_v3 GFF3</p>
<p>Load your annotation file into IGV. Go to ”“File -&gt; Load from File…”. Select “PccAS_v3.gff3” and click “Open”. For more information, see Loading gene annotations in our quick start guide.</p>
<p>This will load a new track called “PccAS_v3.gff3”. The track is currently shown as a density plot.</p>
<p>You will need to zoom in to see individual genes.</p>
<p>Search for the gene PCHAS_0505200 by typing “PCHAS_0505200” in the search box to zoom in and centre the view on PCHAS_0505200.</p>
<p>IGV - PCHAS_0505200</p>
<p>To get a clearer view of the gene structure, right click on the annotation track and click “Expanded”.</p>
<p>IGV - PCHAS_0505200 expanded</p>
<p>In the annotation track, genes are presented as blue boxes and lines. These boxes represent exons, while the lines represent intronic regions. Arrows indicate the direction (or strand) of transcription for each of the genes. Now we have our genome and its annotated features, we just need the read alignments for our five samples.</p>
<p>Load your alignment file for the MT1 sample into IGV. Go to ”“File -&gt; Load from File…”. Select “MT1_sorted.bam” and click “Open”. For more information, see Loading alignment files in our quick start guide.</p>
<p>Note: BAM files and their corresponding index files must be in the same directory for IGV to load them properly.</p>
<p>IGV - MT1 read alignment</p>
<p>This will load a new track called “MT1_sorted.bam” which contains the read alignments for the MT1 sample. We can change how we visualise our data by altering the view options. By default, IGV will display reads individually so they are compactly arranged. If you were to hover over a read in the default view, you will only get the details for that read. However, if we change our view so that the reads are visualised as pairs, the read pairs will be joined together by line and when we hover over either of the reads, we will get information about both of the reads in that pair.</p>
<p>To view our reads as pairs, right click on the MT1_sorted.bam alignment track and click “View as pairs”.</p>
<p>IGV - paired view To condense the alignment, right click on the MT1_sorted.bam alignment track and click “Squished”.</p>
<p>IGV - squished view</p>
<p>For more information on sorting, grouping and visualising read alignments, see the IGV user guide.</p>
<p>Load the remaining sorted BAM files for the MT2 sample and the three SBP samples.</p>
<p>Using the search box in the toolbar, go to PCHAS_1409500. For more information, see Jump to gene or locus in our quick start guide.</p>
<p>IGV - search PCHAS_1409500</p>
<p>The first thing to look at is the coverage range for this viewing window on the left-hand side. The three SBP samples have 2-3 times more reads mapping to this gene than the two MT samples. While at first glance it may seem like this gene may be differentially expressed between the two conditions,</p>
<p>remember that some samples may have been sequenced to a greater depth than others. So, if a</p>
<p>sample has been sequenced to a greater depth we would expect more reads to map in general.</p>
<p>IGV - coverage PCHAS_1409500</p>
<p>134 Visualising transcriptomes with IGV 4.3 Questions</p>
<p>From the gene annotation at the bottom we can also see that there are three annotated exon/CDS</p>
<p>features for this gene. However, the coverage plot suggests there may be a fourth unannotated exon</p>
<p>which, given the direction of the gene, could suggest a 5’ untranslated region (UTR). Note the clean</p>
<p>drop off of the coveraged at around position 377,070.</p>
<p>4.3 Questions</p>
<p>4.3.1 Q1: How many CDS features are there in “PCHAS_1402500”?</p>
<p>Hint: Look at Jump to gene or locus in our quick start guide.</p>
<p>4.3.2 Q2: Does the RNA-seq mapping agree with the gene model in blue?</p>
<p>Hint: Look at the coverage track and split read alignments.</p>
<p>4.3.3 Q3: Do you think this gene is differentially expressed and is looking at the coverage</p>
<p>plots alone a reliable way to assess differential expression?</p>
<p>Hint: Look at the coverage similarities/differences between the MT and SBP samples.</p>
<p>145 Transcript quantification with Kallisto</p>
<p>5 Transcript quantification with Kallisto</p>
<p>5.1 Introduction</p>
<p>After visually inspecting the genome alignment, the next step in a typical RNA-Seq analysis is to</p>
<p>estimate transcript abundance. To do this, reads are assigned to the transcripts they came from.</p>
<p>These assignments are then used to quantify gene or transcript abundance (expression level).</p>
<p>For this tutorial, we are using Kallisto to assign reads to a set of transcript sequences and quantify</p>
<p>transcript abundance. Kallisto does not assemble transcripts and cannot identify novel isoforms. So,</p>
<p>when a reference transcriptome isn’t available, the transcripts will need to be assembled de novo</p>
<p>from the reads. However, for this tutorial, we already have a reference transcriptome available.</p>
<p>The objectives of this part of the tutorial are:</p>
<p>• use Kallisto to index a transcriptome</p>
<p>• use Kallisto to estimate transcript abundance</p>
<p>5.1.1 Quantifying transcripts with Kallisto</p>
<p>Many of the existing methods used for estimating transcript abundance are alignment-based. This</p>
<p>means they rely on mapping reads onto the reference genome. The gene expression levels are then</p>
<p>calculated by counting the number of reads overlapping the transcripts. However, read alignment is</p>
<p>a computationally and time intensive process. So, in this tutorial, we will be running Kallisto which</p>
<p>uses a fast, alignment-free method for transcript quantification.</p>
<p>Near-optimal probabilistic RNA-seq quantification</p>
<p>Nicolas L Bray, Harold Pimentel, Páll Melsted and Lior Pachter</p>
<p>Nat Biotechnol. 2016 May;34(5):525-7. doi: 10.1038/nbt.3519</p>
<p>Kallisto uses pseudoalignment to make it efficient. Rather than looking at where the reads map,</p>
<p>Kallisto uses the compatibility between the reads and transcripts to estimate transcript abundance.</p>
<p>Thus, most transcript quantification with Kallisto can be done on a simple laptop (Figure 3).</p>
<p>Figure 3. Performance of kallisto and other methods</p>
<p>Figure 3. Performance of kallisto and other methods</p>
<p>(a) Accuracy of kallisto, Cufflinks, Sailfish, EMSAR, eXpress and RSEM on 20 RSEM simulations of 30</p>
<p>million 75-bp paired-end reads. (b) Total running time in minutes for processing the 20 simulated data</p>
<p>sets of 30 million paired-end reads described in a. Please see the Kallisto publication for original figure</p>
<p>and more information.</p>
<p>155 Transcript quantification with Kallisto 5.2 Exercise 4</p>
<p>Step 1: building a Kallisto index As with alignment-based methods, Kallisto needs an index. To</p>
<p>generate the index, Kallisto first builds a transcriptome de Bruijn Graph (T-BDG) from all of the</p>
<p>k-mers (short sequences of k nucleotides) that it finds in the transcriptome. Each node in the graph</p>
<p>corresponds to a k-mer and each transcript is represented by its path through the graph. Using these</p>
<p>paths, each k-mer is assigned a k-compatibility class. Some k-mers will be redundant i.e.&nbsp;shared by</p>
<p>the same transcripts. These are skipped to make the index compact and quicker to search. A great</p>
<p>worked example of this process can be found here.</p>
<p>The command kallisto index can be used to build a Kallisto index from transcript sequences.</p>
<p>[ ]: kallisto index</p>
<p>Here we can see the version of Kallisto that we’re using (useful for publication methods) and the</p>
<p>information that we’ll need to give kallisto index. The only information we need to give kallisto</p>
<p>index is the location of our transcript sequences (PccAS_v3_transcripts.fa). However, it’s useful to</p>
<p>have a meaningful filename for the resulting index. We can add this by using the option -i which</p>
<p>expects a value, our index prefix (PccAS_v3_kallisto).</p>
<p>Step 2: estimating transcript abundance With this Kallisto index, you can use kallisto quant</p>
<p>to estimate transcript abundances. You will need to run this command separately for each sample.</p>
<p>[ ]: kallisto quant</p>
<p>We can see that kallisto quant needs us to tell it where our sample read are. Although we don’t</p>
<p>have to, it’s usually a good idea to keep the results of each quantification in a different directory.</p>
<p>This is because the output filename are always the same (e.g.&nbsp;abundances.tsv). If we ran a second</p>
<p>analysis, these could get overwritten. To use a different output directory, we can use the -o option.</p>
<p>We will also be using the -b option for bootstrapping.</p>
<p>Bootstrapping Not all reads will be assigned unambiguously to a single transcript. This means</p>
<p>there will be “noise” in our abundance estimates where reads can be assigned to multiple transcripts.</p>
<p>Kallisto quantifies the uncertainty in its abundance estimates using random resampling and replace-</p>
<p>ment. This process is called bootstrapping and indicates how reliable the expression estimates are</p>
<p>from the observed pseudoalignment. Bootstrap values can be used downstream to distinguish the</p>
<p>technical variability from the biological variability in your experiment.</p>
<p>5.2 Exercise 4</p>
<p>Build an index called PccAS_v3_kallisto from transcript sequences in PccAS_v3_transcripts.fa.</p>
<p>[ ]: kallisto index -i data/PccAS_v3_kallisto data/PccAS_v3_transcripts.fa</p>
<p>165 Transcript quantification with Kallisto 5.2 Exercise 4</p>
<p>Quantify the transcript expression levels for the MT1 sample with 100 bootstrap samples and</p>
<p>calling the output directory MT1.</p>
<p>[ ]: kallisto quant -i data/PccAS_v3_kallisto -o data/MT1 -b 100 \</p>
<p>data/MT1_1.fastq.gz data/MT1_2.fastq.gz</p>
<p>You’ll find your Kallisto results in a new output directory which we called MT1. Let’s take a look.</p>
<p>[ ]: ls data/MT1</p>
<p>Running kallisto quant generated three output files in our MT1 folder:</p>
<p>• abundance.h5</p>
<p>HDF5 binary file containing run info, abundance esimates, bootstrap estimates, and transcript</p>
<p>length information length.</p>
<p>• abundance.tsv</p>
<p>Plain text file containing abundance estimates (doesn’t contain bootstrap estimates).</p>
<p>• run_info.json</p>
<p>JSON file containing information about the run.</p>
<p>Note: when the number of bootstrap values (-b) is very high, Kallisto will generate a large amount</p>
<p>of data. To help, it outputs bootstrap results in HDF5 format (abundance.h5). This file can be read</p>
<p>directly by sleuth.</p>
<p>In the MT1/abundance.tsv file we have the abundance estimates for each gene for the MT1 sample.</p>
<p>Let’s take a quick look.</p>
<p>[ ]: head data/MT1/abundance.tsv</p>
<p>In MT1/abundance.tsv there are five columns which give us information about the transcript abun-</p>
<p>dances for our MT1 sample.</p>
<p>• target_id</p>
<p>Unique transcript identifier.</p>
<p>• length</p>
<p>Number of bases found in exons.</p>
<p>• eff_length</p>
<p>Effective length. Uses fragment length distribution to determine the effective number of posi-</p>
<p>tions that can be sampled on each transcript.</p>
<p>• est_counts</p>
<p>Estimated counts*. This may not always be an integer as reads which map to multiple tran-</p>
<p>scripts are fractionally assigned to each of the corresponding transcripts.</p>
<p>• tpm</p>
<p>Transcripts per million. Normalised value accounting for length and sequence depth bias.</p>
<p>In the last column we have our normalised abundance value for each gene. These are our transcripts</p>
<p>per million or TPM. If you have time at the end of this tutorial, see our normalisation guide which</p>
<p>covers common normalisation methods and has a bonus exercise.</p>
<p>175 Transcript quantification with Kallisto 5.3 Questions</p>
<p>To get the result for a specific gene, we can use grep.</p>
<p>[ ]: grep PCHAS_0100100 data/MT1/abundance.tsv</p>
<p>If we wanted to get the TPM value for a particular gene, we can use awk.</p>
<p>[ ]: awk -F”\t” ‘$1==“PCHAS_0100100” {print $5}’ data/MT1/abundance.tsv</p>
<p>Use kallisto quant four more times, for the MT2 sample and the three SBP samples.</p>
<p>5.3 Questions</p>
<p>5.3.1 Q1: What k-mer length was used to build the Kallisto index?</p>
<p>Hint: look at the terminal output from kallisto index</p>
<p>5.3.2 Q2: How many transcript sequences are there in PccAS_v3_transcripts.fa?</p>
<p>Hint: you can use grep or look at the terminal output from kallisto quant or in the run_info.json</p>
<p>files</p>
<p>5.3.3 Q3: What is the transcripts per million (TPM) value for PCHAS_1402500 in each of</p>
<p>the samples?</p>
<p>Hint: use grep to look at the abundance.tsv files</p>
<p>5.3.4 Q4: Do you think PCHAS_1402500 is differentially expressed?</p>
<p>186 Identifying differentially expressed genes with Sleuth</p>
<p>6 Identifying differentially expressed genes with Sleuth</p>
<p>6.1 Introduction</p>
<p>In the previous sections, we have quantified our transcript abundance and looked at why counts are</p>
<p>normalised. In this section, you will be using sleuth to do some simple quality checks and get a first</p>
<p>look at the results.</p>
<p>The objectives of this part of the tutorial are:</p>
<p>• use sleuth to perform quality control checks</p>
<p>• use sleuth to identify differentially expressed (DE) transcripts</p>
<p>• use sleuth to investigate DE transcripts</p>
<p>6.1.1 Differential expression analysis (DEA)</p>
<p>Differential expression analysis tries to identify genes whose expression levels differ between exper-</p>
<p>imental conditions. We don’t normally have enough replicates to do traditional tests of significance</p>
<p>for RNA-Seq data. So, most methods look for outliers in the relationship between average abundance</p>
<p>and fold change and assume most genes are not differentially expressed.</p>
<p>Rather than just using a fold change threshold to determine which genes are differentially expressed,</p>
<p>DEAs use a variety of statistical tests for significance. These tests give us a p-value which is an</p>
<p>estimate of how often your observations would occur by chance.</p>
<p>However, we perform these comparisons for each one of the thousands of genes/transcripts in our</p>
<p>dataset. A p-value of 0.01 estimates a probability of 1% for seeing our observation just by chance. In</p>
<p>an experiment like ours with 5,000 genes we would expect 5 genes to be significantly differentially</p>
<p>expressed by chance (i.e.&nbsp;even if there were no difference between our conditions). Instead of using</p>
<p>a p-value we use a q-value to account for multiple testing and adjusts the p-value accordingly.</p>
<p>6.1.2 sleuth</p>
<p>sleuth is a companion tool for Kallisto. Unlike most other tools, sleuth can utilize the technical</p>
<p>variation information generated by Kallisto so that you can look at both the technical and biological</p>
<p>variation in your dataset.</p>
<p>For the DEA, sleuth essentially tests two models, one which assumes that the abundances are equal</p>
<p>between the two conditions (reduced) and one that does not (full). To identify DE transcripts it</p>
<p>identifies those with a significantly better fit to the “full” model. For more information on sleuth</p>
<p>and how it works, see Lior Pachter’s blog post A sleuth for RNA-Seq (https://liorpachter.word-</p>
<p>press.com/2015/08/17/a-sleuth-for-rna-seq/).</p>
<p>sleuth is written in the R statistical programming language, as is almost all RNA-Seq analysis soft-</p>
<p>ware. Helpfully, it produces a web page that allows interactive graphical analysis of the data. How-</p>
<p>ever, we strongly recommend learning R for anyone doing a significant amount of RNA-seq analysis.</p>
<p>It is nowhere near as hard to get started with as full-blown programming languages such as Perl or</p>
<p>Python!</p>
<p>196 Identifying differentially expressed genes with Sleuth 6.2 Exercise 5</p>
<p>6.2 Exercise 5</p>
<p>For this tutorial, we’ve provided a series of R commands as an R script that will get sleuth running.</p>
<p>6.2.1 Running sleuth</p>
<p>The commands we need to run sleuth are in the file sleuth.R. There’s a great overview of the com-</p>
<p>mands and what they do by the developers of sleuth here: https://pachterlab.github.io/sleuth_walk-</p>
<p>throughs/trapnell/analysis.html. Using R is not as hard as it seems, most of this script was copied</p>
<p>from the manual!</p>
<p>Open sleuth.R and have a quick look at the commands.</p>
<p>[ ]: cat data/sleuth.R</p>
<p>You may also want to have a look at hiseq_info.txt which is where we define which condition each</p>
<p>sample is associated with.</p>
<p>[ ]: cat data/hiseq_info.txt</p>
<p>You can run scripts containing R commands using Rscript followed by the script name. Run</p>
<p>sleuth.R.</p>
<p>[ ]: Rscript data/sleuth.R</p>
<p>You won’t see any output from this script in the notebook, just a * next to the command input ([*])</p>
<p>to let you know it’s running.</p>
<p>If you were to run the script directly on the command line, sleuth will return a link which you can</p>
<p>follow (http://127.0.0.1:42427). This will take you to a web page where you can navigate and</p>
<p>explore the sleuth results.</p>
<p>Type the URL below into your a web browser (e.g.&nbsp;chrome or firefox) to open the sleuth results.</p>
<p>http://127.0.0.1:42427</p>
<p>You should now see a page with the heading “sleuth live”. If not, just give the script a little longer</p>
<p>and then refresh the page.</p>
<p>206 Identifying differentially expressed genes with Sleuth 6.2 Exercise 5</p>
<p>6.2.2 Using sleuth to quality check (QC) transcript quanification</p>
<p>Quality control checks are absolutely vital at every step of the experimental process. We can use</p>
<p>sleuth to perform simple quality checks (QC) on our dataset.</p>
<p>At the top of the page, sleuth provides several tabs which we can use to determine whether the data</p>
<p>is of good quality and whether we should trust the results we get.</p>
<p>First, lets take a look at a summary of our dataset.</p>
<p>In the web page that has been launched, click on “summaries -&gt; processed data”.</p>
<p>Notice that the number of reads mapping differs quite a bit between MT and SBP samples? This is</p>
<p>why we QC our data. In the MT samples &gt;95% of the reads mapped to the genome, but only 15-30%</p>
<p>are assigned to the transcriptome compared to &gt;75% for the SBP samples. This suggests that there</p>
<p>may be some residual ribosomal RNA left over from the RNA preparation. It’s not a problem as we</p>
<p>have enough reads and replicates for our analysis.</p>
<p>sleuth - processed data table</p>
<p>In some cases, we can identify samples which don’t agree with other replicates (outliers) and sam-</p>
<p>ples which are related by experimental bias (batch effects). If we don’t have many replicates, it’s</p>
<p>hard to detect outliers and batch effects meaning our power to detect DE genes is reduced.</p>
<p>Principal component analysis (PCA) plots can be used to look at variation and strong patterns</p>
<p>within the dataset. Batch effects and outliers often stand out quite clearly in the PCA plot and mean</p>
<p>that you can account for them in any downstream analysis.</p>
<p>sleuth - PCA plot</p>
<p>216 Identifying differentially expressed genes with Sleuth 6.2 Exercise 5</p>
<p>Our samples form two condition-related clusters with the two MT samples (red) on the left and the</p>
<p>three SBP samples on the right (blue). If we look at the variance bar plot, we can see that the first</p>
<p>principal component (PC1) accounts for &gt;90% of the variation in our dataset. As the samples are</p>
<p>clearly clustered on the x-axis (PC1) this suggests that most of the variation in the dataset is related</p>
<p>to our experimental condition (Mt vs SBP).</p>
<p>sleuth - variance bar plot</p>
<p>6.2.3 Using sleuth to look at DE transcripts</p>
<p>We used the output from Kallisto to identify DE transcripts using sleuth. Let’s take a look and see if</p>
<p>we found any.</p>
<p>To see the results of the sleuth DEA, go to “analyses -&gt; test table”.</p>
<p>sleuth - transcript table</p>
<p>The important columns here are the q-value and the beta value (analagous to fold change). By</p>
<p>default, the table is sorted by the q-value. We can see that our top transcript is PCHAS_0420800, a</p>
<p>hypothetical protein/pseudogene. Now let’s take a closer look at that transcript.</p>
<p>226 Identifying differentially expressed genes with Sleuth 6.2 Exercise 5</p>
<p>Go to “analyses -&gt; transcript view”. Enter “PCHAS_0420800” into the “transcript” search box.</p>
<p>Click “view”.</p>
<p>sleuth - transcript view</p>
<p>On the left you have the abundances for the MT replicates and on the right, the SBP replicates. We</p>
<p>can see that this transcript is more highly expressed in the MT samples than in the SBP samples.</p>
<p>This is also reflected by the fold change in the test table (b = -4.5). The b value is negative as it</p>
<p>represents the fold change in SBP samples relative to those in the MT samples.</p>
<p>Finally, let’s take a look at the gene level.</p>
<p>To see the results of the sleuth DEA, go to “analyses -&gt; test_table”. Under “table type” select</p>
<p>“gene table”. Click on the column header “qval” in the table to sort the rows by ascending</p>
<p>q-value.</p>
<p>sleuth - gene table</p>
<p>The transcripts have now been grouped by their descriptions. Let’s take a closer look at the CIR</p>
<p>proteins.</p>
<p>236 Identifying differentially expressed genes with Sleuth 6.3 Questions</p>
<p>Go to “analyses -&gt; gene view”. In the “gene” search box enter “CIR protein” (without the</p>
<p>quotes).</p>
<p>sleuth - gene view</p>
<p>Here we can see the individual CIR protein transcript abundances. We can see that PCHAS_1100300</p>
<p>is more highly expressed in the SBP samples while PCHAS_0302100 and PCHAS_0302100 are more</p>
<p>highly expressed in the MT samples.</p>
<p>6.3 Questions</p>
<p>6.3.1 Q1: Is our gene from earlier, PCHAS_1402500, significantly differentially expressed?</p>
<p>247 Interpreting the results</p>
<p>7 Interpreting the results</p>
<p>7.1 Introduction</p>
<p>The main objective of this part of the tutorial is to use simple Unix commands to get a list of signifi-</p>
<p>cantly differentially expressed genes. Using this gene list and the quantitative information from our</p>
<p>analysis we can then start to make biological inferences about our dataset.</p>
<p>Using the R script (sleuth.R), we printed out a file of results describing the differentially expressed</p>
<p>genes in our dataset. This file is called kallisto.results.</p>
<p>The file contains several columns, of which the most important are:</p>
<p>• Column 1: target_id (gene id)</p>
<p>• Column 2: description (some more useful description of the gene than its id)</p>
<p>• Column 3: pval (p value)</p>
<p>• Column 4: qval (p value corrected for multiple hypothesis testing)</p>
<p>• Column 5: b (fold change)</p>
<p>With a little Linux magic we can get the list of differentially expressed genes with only the columns</p>
<p>of interest as above.</p>
<p>## Exercise 6</p>
<p>To get the genes which are most highly expressed in our SBP samples, we must first filter our re-</p>
<p>sults. There are two columns we want to filter our data on: b (column 5) and qval (column 4).</p>
<p>These columns represent whether the gene is differentially expressed and whether that change is</p>
<p>significant.</p>
<p>The following command will get those genes which have an adjusted p value (qval) less than 0.01</p>
<p>and a positive fold change. These genes are more highly expressed in the SBP samples.</p>
<p>[ ]: awk -F “\t” ‘$4 &lt; 0.01 &amp;&amp; $5 &gt; 0’ data/kallisto.results | cut -f1,2,3,4,5 | head</p>
<p>We used awk to filter the gene list and print only the lines which met our search criteria (qval &gt;</p>
<p>0.01, b &gt; 0). The option -F tells awk what delimiter is used to separate the columns. In this case,</p>
<p>it was a tab or its regular expression ””. We then use cut to only print out columns 1-5. You can also</p>
<p>do that within the awk command. Finally, we use head to get the first 10 lines of the output.</p>
<p>Alternatively, we can look for the genes which are more highly expressed in the MT samples.</p>
<p>[ ]: awk -F “\t” ‘$4 &lt; 0.01 &amp;&amp; $5 &lt; 0’ data/kallisto.results | cut -f1,2,3,4,5 | head</p>
<p>It can be useful to have a quick look and compare gene lists. For example, whether a certain gene</p>
<p>product is seen more often in the genes most highly expressed in one condition or another. A quick</p>
<p>and dirty method would be to use the gene descriptions (or gene products).</p>
<p>257 Interpreting the results 7.2 Questions</p>
<p>You could extract the gene products (column 2) for genes which are more highly expressed in the</p>
<p>SBP samples using sort and then uniq.</p>
<p>[ ]: awk -F “\t” ‘$4 &lt; 0.01 &amp;&amp; $5 &lt; 0 {print $2}’ data/kallisto.results | sort | uniq</p>
<p>We can count each time these unique gene products occur in the list using uniq -c.</p>
<p>[ ]: awk -F “\t” ‘$4 &lt; 0.01 &amp;&amp; $5 &lt; 0 {print $2}’ data/kallisto.results | \</p>
<p>sort | uniq -c</p>
<p>And, if we wanted to make it a bit easier to see commonly found gene products we can sort this</p>
<p>again by the frequency count we got from the uniq command. The sort command will put these</p>
<p>in ascending numerical (-n) order.</p>
<p>[ ]: awk -F “\t” ‘$4 &lt; 0.01 &amp;&amp; $5 &lt; 0 {print $2}’ data/kallisto.results | \</p>
<p>sort | uniq -c | sort -n</p>
<p>If you wanted to look for the frequency of a particular gene product you could also use grep.</p>
<p>[ ]: awk -F “\t” ‘$4 &lt; 0.01 &amp;&amp; $5 &lt; 0 {print $2}’ data/kallisto.results | grep -c CIR</p>
<p>Or building on the earlier command:</p>
<p>[ ]: awk -F “\t” ‘$4 &lt; 0.01 &amp;&amp; $5 &lt; 0 {print $2}’ data/kallisto.results | \</p>
<p>sort | uniq -c | grep CIR</p>
<p>If you want to read more about this work related to this data it is published:</p>
<p>Vector transmission regulates immune control of Plasmodium virulence</p>
<p>Philip J. Spence, William Jarra, Prisca Lévy, Adam J. Reid, Lia Chappell, Thibaut Brugat,</p>
<p>Mandy Sanders, Matthew Berriman and Jean Langhorne</p>
<p>Nature. 2013 Jun 13; 498(7453): 228–231 doi:10.1038/nature12231</p>
<p>Q1: How many genes are more highly expressed in the SBP samples?</p>
<p>Hint: try replacing head in the earlier command with another unix command to count the number of</p>
<p>7.2 Questions</p>
<p>7.2.1 lines</p>
<p>7.2.2 Q2: How many genes are more highly expressed in the MT samples?</p>
<p>Hint: try replacing head in the earlier command with another unix command to count the number of</p>
<p>lines</p>
<p>267 Interpreting the results 7.2 Questions</p>
<p>7.2.3 Q3: Do you notice any particular genes that came up in the analysis?</p>
<p>Hint: look for gene products that are seen more often in genes more highly expressed in the SBP samples</p>
<p>than those more highly expressed in the MT samples</p>
<p>278 Key aspects of differential expression analysis</p>
<p>8 Key aspects of differential expression analysis</p>
<p>8.1 Replicates and power</p>
<p>In order to accurately ascertain which genes are differentially expressed and by how much it is nec-</p>
<p>essary to use replicated data. As with all biological experiments doing it once is simply not enough.</p>
<p>There is no simple way to decide how many replicates to do, it is usually a compromise of statistical</p>
<p>power and cost. By determining how much variability there is in the sample preparation and se-</p>
<p>quencing reactions, we can better assess how highly genes are really expressed and more accurately</p>
<p>determine any differences. The key to this is performing biological rather than technical replicates.</p>
<p>This means, for instance, growing up three batches of parasites, treating them all identically, ex-</p>
<p>tracting RNA from each and sequencing the three samples separately. Technical replicates, whereby</p>
<p>the same sample is sequenced three times do not account for the variability that really exists in</p>
<p>biological systems or the experimental error between batches of parasites and RNA extractions.</p>
<p>Note: more replicates will help improve power for genes that are already detected at high levels, while</p>
<p>deeper sequencing will improve power to detect differential expression for genes which are expressed at</p>
<p>low levels.</p>
<p>8.2 p-values vs.&nbsp;q-values</p>
<p>When asking whether a gene is differentially expressed we use statistical tests to assign a p-value. If</p>
<p>a gene has a p-value of 0.05, we say that there is only a 5% chance that it is not really differentially</p>
<p>expressed. However, if we are asking this question for every gene in the genome (~5500 genes for</p>
<p>Plasmodium), then we would expect to see p-values less than 0.05 for many genes even though they</p>
<p>are not really differentially expressed. Due to this statistical problem, we must correct the p-values</p>
<p>so that we are not tricked into accepting a large number of erroneous results. Q-values are p-values</p>
<p>which have been corrected for what is known as multiple hypothesis testing. Therefore, it is a q-</p>
<p>value of less than 0.05 that we should be looking for when asking whether a gene is differentially</p>
<p>expressed.</p>
<p>8.3 Alternative software</p>
<p>If you have a good quality genome and genome annotation such as for model organisms e.g.&nbsp;human,</p>
<p>mouse, Plasmodium; map to the transcriptome to determine transcript abundance. This is even more</p>
<p>relevant if you have variant transcripts per gene as you need a tool which will do its best to determine</p>
<p>which transcript is really expressed. As well as Kallisto (Bray et al.&nbsp;2016; PMID: 27043002), there</p>
<p>is eXpress (Roberts &amp; Pachter, 2012; PMID: 23160280) which will do this.</p>
<p>Alternatively, you can map to the genome and then call abundance of genes, essentially ignoring</p>
<p>variant transcripts. This is more appropriate where you are less confident about the genome an-</p>
<p>notation and/or you don’t have variant transcripts because your organism rarely makes them or</p>
<p>they are simply not annotated. Tophat2 (Kim et al., 2013; PMID: 23618408), HISAT2 (Pertea et</p>
<p>al.&nbsp;2016; PMID: 27560171), STAR (Dobinet al., 2013; PMID: 23104886) and GSNAP (Wu &amp; Nacu,</p>
<p>2010; PMID: 20147302) are all splice-aware RNA-seq read mappers appropriate for this task. You</p>
<p>then need to use a tool which counts the reads overlapping each gene model. HTSeq (Anders et al.,</p>
<p>288 Key aspects of differential expression analysis 8.4 What do I do with a gene list?</p>
<p>2015; PMID: 25260700) is a popular tool for this purpose. Cufflinks (Trapnell et al.&nbsp;2012; PMID:</p>
<p>22383036) will count reads and determine differentially expressed genes.</p>
<p>There are a variety of programs for detecting differentially expressed genes from tables of RNA-seq</p>
<p>read counts. DESeq2 (Love et al., 2014; PMID: 25516281), EdgeR (Robinson et al., 2010; PMID:</p>
<p>19910308) and BaySeq (Hardcastle &amp; Kelly, 2010; PMID: 20698981) are good examples.</p>
<p>8.4 What do I do with a gene list?</p>
<p>Differential expression analysis results are a list of genes which show differences between two con-</p>
<p>ditions. It can be daunting trying to determine what the results mean. On one hand, you may find</p>
<p>that that there are no real differences in your experiment. Is this due to biological reality or noisy</p>
<p>data? On the other hand, you may find several thousands of genes are differentially expressed.</p>
<p>What can you say about that?</p>
<p>Other than looking for genes you expect to be different or unchanged, one of the first things to</p>
<p>do is look at Gene Ontology (GO) term enrichment. There are many different algorithms for</p>
<p>this, but you could annotate your genes with functional terms from GO using for instance Blast2GO</p>
<p>(Conesa et al., 2005; PMID: 16081474) and then use TopGO (Alexa et al., 2005; PMID: 16606683)</p>
<p>to determine whether any particular sorts of genes occur more than expected in your differentially</p>
<p>expressed genes.</p>
<p>8.5 Congratulations, you have reached the end of this tutorial!</p>
<p>We hope you’ve enjoyed our RNA-Seq tutorial!</p>
<p>299 Normalisation</p>
<p>9 Normalisation</p>
<p>9.1 Introduction</p>
<p>In the previous section, we looked at estimating transcript abundance with Kallisto. The abundances</p>
<p>are reported as transcripts per million (TPM), but what does TPM mean and how is it calculated?</p>
<p>The objectives of this part of the tutorial are:</p>
<p>• understand why RNA-Seq normalisation metrics are used</p>
<p>• understand the difference between RPKM, FPKM and TPM</p>
<p>• calculate RPKM and TPM for a gene of interest</p>
<p>There are many useful websites, publications and blog posts which go into much more detail about</p>
<p>RNA-Seq normalisation methods. Here are just a couple (in no particular order):</p>
<p>• What the FPKM? A review of RNA-Seq expression units</p>
<p>• RPKM, FPKM and TPM, clearly explained</p>
<p>• A survey of best practices for RNA-seq data analysis</p>
<p>• The RNA-seq abundance zoo</p>
<p>9.2 Why do we use normalisation units instead of raw counts?</p>
<p>Raw reads counts are the number of reads originating from each transcript which can be affected</p>
<p>by several factors:</p>
<p>• sequencing depth (total number of reads)</p>
<p>The more we sequence a sample, the more reads we expect to be assigned.</p>
<p>• gene/transcript length</p>
<p>The longer the gene or transcript, the more reads we expect to be assigned to it.</p>
<p>Figure 4. Effect of sequencing depth and gene length on raw read counts</p>
<p>309 Normalisation 9.2 Why do we use normalisation units instead of raw counts?</p>
<p>Look at the top part of Figure 4. In which sample, X or Y, is the gene more highly expressed?</p>
<p>Neither, it’s the same in both. What we didn’t tell you was that the total number of reads generated</p>
<p>for sample A was twice the number than for sample B. That meant almost twice the number of reads</p>
<p>are assigned to the same gene in sample A than in sample B.</p>
<p>Look at the bottom part of Figure 4. Which gene, X or Y, has the greatest gene level expression?</p>
<p>Neither, they are both expressed at the same level. This time we didn’t tell you that gene X is twice</p>
<p>the length of gene Y. This meant that almost twice the number reads were assigned to gene X than</p>
<p>gene Y.</p>
<p>In the top part of Figure 4, the gene in sample X has twice the number of reads assigned to it than the</p>
<p>same gene in sample Y. What isn’t shown is that sample X had twice the number or total reads than</p>
<p>sample Y so we would expect more reads to be assigned in sample X. Thus, the gene is expressed at</p>
<p>roughly the same level in both samples. In the bottom part of Figure 4, gene X has twice the number</p>
<p>of reads assigned to it than gene Y. However, gene X is twice the length of gene Y and so we expect</p>
<p>more reads to be assigned to gene X. Again, the expression level is roughly the same.</p>
<p>9.2.1 Reads per kilobase per million (RPKM)</p>
<p>Reads per kilobase (of exon) per million (reads mapped) or RPKM is a within sample normalisation</p>
<p>method which takes into account sequencing depth and length biases.</p>
<p>To calculate RPKM, you first normalise by sequencing depth and then by gene/transcript length.</p>
<p>1. Get your per million scaling factor</p>
<p>Count up the total number of reads which have been assigned (mapped) in the sample. Divide</p>
<p>this number by 1,000,000 (1 million) to get your per million scaling factor (N).</p>
<p>2. Normalise for sequencing depth</p>
<p>Divide the number of reads which have been assigned to the gene or transcript (C) by the per</p>
<p>million scaling factor you calculated in step 1. This will give you your reads per million (RPM).</p>
<p>3. Get your per kilobase scaling factor</p>
<p>Divide the total length of the exons in your transcript or gene in base pairs by 1,000 (1 thou-</p>
<p>sand) to get your per kilobase scaling factor (L).</p>
<p>4. Normalise for length</p>
<p>Divide your RPM value from step 2 by your per kilobase scaling factor (length of the gene/-</p>
<p>transcript in kilobases) from step 3. This will give you your reads per kilobase per million or</p>
<p>RPKM.</p>
<p>This can be simplified into the following equation:</p>
<p>C</p>
<p>RP KM=</p>
<p>LN</p>
<p>319 Normalisation 9.2 Why do we use normalisation units instead of raw counts?</p>
<p>Where:</p>
<p>• C is number of reads mapped to the transcript or gene</p>
<p>• L is the total exon length of the transcript or gene in kilobases</p>
<p>• N is the total number of reads mapped in millions</p>
<p>9.2.2 Fragments per kilobase per million (FPKM)</p>
<p>Fragments per kilobase per million or FPKM is essentially the same as RPKM except that:</p>
<p>• RPKM is designed for single-end RNA-Seq experiments</p>
<p>• FPKM is designed for paired-end RNA-Seq experiments</p>
<p>In a paired-end RNA-Seq experiment, two reads may be assigned to a single fragment (in any ori-</p>
<p>entation). Also, in some cases, only one of those reads will be assigned to a fragment (singleton).</p>
<p>The only difference between RPKM and FPKM is that FPKM takes into consideration that two reads</p>
<p>may be assigned to the same fragment.</p>
<p>9.2.3 Transcripts per million (TPM)</p>
<p>Calculating the transcripts per million or TPM is a similar process to RPKM and FPKM. The main</p>
<p>difference is that you will first normalise for length bias and then for sequencing depth bias. In a</p>
<p>nut shell, we are swapping the order of normalisations.</p>
<p>1. Get your per kilobase scaling factor</p>
<p>Divide the total length of the exons in your transcript in base pairs by 1,000 (1 thousand) to</p>
<p>get your per kilobase scaling factor.</p>
<p>2. Normalise for length</p>
<p>Divide the number of reads which have been assigned to the transcript by the per kilobase</p>
<p>scaling factor you calculated in step 1. This will give you your reads per kilobase (RPK).</p>
<p>3. Get the sum of all RPK values in your sample</p>
<p>Calculate the RPK value for all of the transcripts in your sample. Add all of these together to</p>
<p>get your total RPK value.</p>
<p>4. Get your per million scaling factor</p>
<p>Divide your total RPK value from step 3 by 1,000,000 (1 million) to get your per million scaling</p>
<p>factor.</p>
<p>5. Normalise for sequencing depth</p>
<p>Divide your RPK value calculated in step 2 by the per million scaling factor from step 4. You</p>
<p>now have your transcripts per millions value or TPM.</p>
<p>329 Normalisation 9.3 Calculating RPKM and TPM values</p>
<p>9.3 Calculating RPKM and TPM values</p>
<p>To try and answer this, let’s look at a worked example. Here, we have three genes (A-C) and three</p>
<p>biological replicates (1-3).</p>
<p>Gene Length Replicate 1 Replicate 2 Replicate 3</p>
<p>A 2,000 bases 10 12 30</p>
<p>B 4,000 bases 20 25 60</p>
<p>C 1,000 bases 5 8 15</p>
<p>There are two things to notice in our dataset:</p>
<p>• Gene B has twice number reads mapped than gene A, possibly as it’s twice the length</p>
<p>• Replicate 3 has more reads mapped than any of the other replicates, regardless of which gene</p>
<p>we look at</p>
<p>9.3.1 Calculating RPKM</p>
<p>Step 1: get your per million scaling factor In the table below is the total number of reads which</p>
<p>mapped for each of the replicates. To get our per million scaling factor, we divide each of these</p>
<p>values by 1,000,000 (1 million).</p>
<p>Gene Replicate 1 Replicate 2 Replicate 3</p>
<p>Total reads mapped 3,500,000 4,500,000 10,600,000</p>
<p>Per million reads 3.5 4.5 10.6</p>
<p>Step 2: normalise for sequencing depth factor to get our reads per million (RPM).</p>
<p>Before:</p>
<p>We now divide our read counts by the per million scaling</p>
<p>Gene Replicate 1 Replicate 2 Replicate 3</p>
<p>A 10 12 30</p>
<p>B 20 25 60</p>
<p>C 5 8 15</p>
<p>339 Normalisation 9.3 Calculating RPKM and TPM values</p>
<p>After:</p>
<p>Gene Replicate 1 RPM Replicate 2 RPM Replicate 3 RPM</p>
<p>A 2.857 2.667 2.830</p>
<p>B 5.714 5.556 5.660</p>
<p>C 1.429 1.778 1.415</p>
<p>Step 3: get your per kilobase scaling factor Here we have our gene length in base pairs. For our</p>
<p>per kilobase scaling factor we need to get our gene length in kilobases by dividing it by 1,000.</p>
<p>Gene Length (base pairs) Length (kilobases)</p>
<p>A 2,000 2</p>
<p>B 4,000 4</p>
<p>C 1,000 1</p>
<p>Step 4: normalise for length Finally, we divide our RPM values from step 2 by our per kilobase</p>
<p>scaling factor from step 3 to get our reads per kilobase per million (RPKM).</p>
<p>Before:</p>
<p>Gene Replicate 1 RPM Replicate 2 RPM Replicate 3 RPM</p>
<p>A 2.857 2.667 2.830</p>
<p>B 5.714 5.556 5.660</p>
<p>C 1.429 1.778 1.415</p>
<p>After:</p>
<p>Gene Replicate 1 RPKM Replicate 2 RPKM Replicate 3 RPKM</p>
<p>A 1.43 1.33 1.42</p>
<p>B 1.43 1.39 1.42</p>
<p>C 1.43 1.78 1.42</p>
<p>Notice that even though replicate 3 had more reads assigned than the other samples and a greater</p>
<p>sequencing depth, its RPKM is quite similar. And, that although gene B had twice the number of</p>
<p>349 Normalisation 9.3 Calculating RPKM and TPM values</p>
<p>reads assigned than gene A, its RPKM is the same. This is because we have normalised by both</p>
<p>length and sequencing depth.</p>
<p>9.3.2 Calculating TPM</p>
<p>Now we’re going to calculate the TPM values for the same example data. As a reminder, here are</p>
<p>our three genes (A-C) and three biological replicates (1-3).</p>
<p>Gene Length Replicate 1 Replicate 2 Replicate 3</p>
<p>A 2,000 bases 10 12 30</p>
<p>B 4,000 bases 20 25 60</p>
<p>C 1,000 bases 5 8 15</p>
<p>Step 1: get your per kilobase scaling factor Again, our gene lengths are in base pairs. For our</p>
<p>per kilobase scaling factor we need to get our gene length in kilobases by dividing it by 1,000.</p>
<p>Gene Length (base pairs) Length (kilobases)</p>
<p>A 2,000 2</p>
<p>B 4,000 4</p>
<p>C 1,000 1</p>
<p>Step 2: normalise for length Now we divide the number of reads which have been assigned to</p>
<p>each gene by the per kilobase scaling factor we just calculated. This will give us our reads per</p>
<p>kilobase (RPK).</p>
<p>Before:</p>
<p>Gene Replicate 1 Replicate 2 Replicate 3</p>
<p>A 10 12 30</p>
<p>B 20 25 60</p>
<p>C 5 8 15</p>
<p>359 Normalisation 9.3 Calculating RPKM and TPM values</p>
<p>After:</p>
<p>Gene Replicate 1 Replicate 2 Replicate 3</p>
<p>A 5 6 15</p>
<p>B 5 6.25 15</p>
<p>C 5 8 15</p>
<p>Step 3: get the sum of all RPK values in your sample Next, we sum the RPK values for each of</p>
<p>our replices. This will give use our total RPK value for each replicate. To make this example scalable,</p>
<p>we assume there are other genes so the total RPK is made up.</p>
<p>Gene Replicate 1 Replicate 2 Replicate 3</p>
<p>A 5 6 15</p>
<p>B 5 6.25 15</p>
<p>C 5 8 15</p>
<p>… … … …</p>
<p>Total RPK 150,000 202,500 450,000</p>
<p>Step 4: get your per million scaling factor Here, instead of dividing our total mapped reads</p>
<p>by 1,000,000 (1 million) to get our per million scaling factor, we divide our total RPK values by</p>
<p>1,000,000 (1 million).</p>
<p>Gene Replicate 1 Replicate 2 Replicate 3</p>
<p>Total RPK 150,000 202,500 450,000</p>
<p>Per million RPK 0.1500 0.2025 0.4500</p>
<p>369 Normalisation 9.4 Which normalisation unit should I use?</p>
<p>Step 5: normalise for sequencing depth Finally, we divide our individual RPK values from step</p>
<p>2 by the per million scaling factor in step 4 to give us our TPM values.</p>
<p>Before:</p>
<p>Gene Replicate 1 Replicate 2 Replicate 3</p>
<p>A 5 6 15</p>
<p>B 5 6.25 15</p>
<p>C 5 8 15</p>
<p>After:</p>
<p>Gene Replicate 1 Replicate 2 Replicate 3</p>
<p>A 33.33 29.63 33.33</p>
<p>B 33.33 30.86 33.33</p>
<p>C 33.33 39.51 33.33</p>
<p>9.4 Which normalisation unit should I use?</p>
<p>Well, there’s a lot of debate around this, so let’s look at our total normalised values for each replicate.</p>
<p>9.4.1 RPKM</p>
<p>Gene Replicate 1 RPKM Replicate 2 RPKM Replicate 3 RPKM</p>
<p>A 1.43 1.33 1.42</p>
<p>B 1.43 1.39 1.42</p>
<p>C 1.43 1.78 1.42</p>
<p>Total RPKM 4.29 4.50 4.25</p>
<p>9.4.2 TPM</p>
<p>Gene Replicate 1 Replicate 2 Replicate 3</p>
<p>A 33.33 29.63 33.33</p>
<p>B 33.33 30.86 33.33</p>
<p>379 Normalisation 9.5 Questions</p>
<p>Gene Replicate 1 Replicate 2 Replicate 3</p>
<p>C 33.33 39.51 33.33</p>
<p>Total TPM 100 100 100</p>
<p>Notice that that total TPM value for each of the replicates is the same. This is not true for RPKM</p>
<p>and FPKM where the total values differ. With TPM, having the same total value for each replicate</p>
<p>makes it easier to compare the proportion of reads mapping to each gene across replicates (although</p>
<p>you shouldn’t really compare across experiments). With RPKM and FPKM, the differing total values</p>
<p>make it much harder to compare replicates.</p>
<p>9.5 Questions</p>
<p>Below is the information for each of the five samples. You will need this information to answer the</p>
<p>questions. We have put all of commands used to get this information in the answers.</p>
<p>Sample Total mapped reads Transcript length Assigned reads Total RPK</p>
<p>MT1 2,353,750 3,697 2,541 293,431</p>
<p>MT2 2,292,271 3,709 3,392 675,190</p>
<p>SBP1 2,329,235 3,699 14,605 1,719,970</p>
<p>SBP2 2,187,718 3,696 17,302 1,429,540</p>
<p>SBP3 2,163,979 3,699 14,646 1,561,310</p>
<p>Note: values have been rounded up to integers to make calculations easier. Assigned reads are the</p>
<p>est_count from Kallisto for PCHAS_1402500. Transcript lengths are the est_length from Kallisto for</p>
<p>PCHAS_1402500.</p>
<p>389 Normalisation 9.5 Questions</p>
<p>Q1: Using the abundance.tsv files generated by Kallisto and the information above, calculate</p>
<p>the RPKM for PCHAS_1402500 in each of our five samples.</p>
<p>Sample Per million scaling factor RPM Per kilobase scaling factor RPKM</p>
<p>MT1</p>
<p>MT2</p>
<p>SBP1</p>
<p>SBP2</p>
<p>SBP3</p>
<p>Q2: Using the abundance.tsv files generated by Kallisto and the information above, calculate</p>
<p>the TPM for PCHAS_1402500 in each of our five samples.</p>
<p>Hint: don’t forget to get your per million scaling factor.</p>
<p>Sample Per kilobase scaling factor Reads per kilobase (RPK) TPM</p>
<p>MT1</p>
<p>MT2</p>
<p>SBP1</p>
<p>SBP2</p>
<p>SBP3</p>
<p>Q3: Do these match the TPM values from Kallisto?</p>
<p>Hint: look at the abundance.tsv files for each of your samples.</p>
<p>Q4: Do you think PCHAS_1402500 is differentially expressed between the MT and SBP sam-</p>
<p>ples?</p>
<p>3910 Running commands on multiple samples</p>
<p>10 Running commands on multiple samples</p>
<p>Now, fair warning, you’re going to wish we’d told you this earlier on. However, then you wouldn’t</p>
<p>have had the fun of running and updating each of the previous commands, growling at typos and</p>
<p>generally wishing that you’d gone for that cup of coffee before starting this tutorial.</p>
<p>Here we go….we can use a loop to run the same commands for multiple samples.</p>
<p>There’s a great introduction to bash scripting and loops as part of our Unix module. But let’s take a</p>
<p>look at how we could have generated genome alignments for all of our samples using a single loop.</p>
<p>Whenever you write a loop, it’s always a good idea to build it up slowly to check that it’s doing what</p>
<p>you think.</p>
<p>[ ]: for r in data/*.fastq.gz</p>
<p>do</p>
<p>echo $r</p>
<p>done</p>
<p>This loop looks for all (*) files which end with “.fastq.gz”. The for loop then executes a sequence</p>
<p>of commands for each file name that it finds. In the first iteration its “data/MT1_1.fastq.gz”, then</p>
<p>“data/MT1_2.fastq.gz” and so on… In each iteration, we assigned each filename that it found to a</p>
<p>variable called “r”.</p>
<p>for r in *.fastq.gz</p>
<p>Then, to check we got what we expected, we printed what the variable “r” represented back to the</p>
<p>terminal. Because we want to use the variable (“r”) we created we need to use dollar ($) symbol.</p>
<p>echo $r</p>
<p>Now, if we left things as they are, we would be running the commands twice for each sample. This</p>
<p>is because we have two FASTQ files for each sample i.e.&nbsp;”_1.fastq.gz” and ”_2.fastq.gz“. Let’s change</p>
<p>our loop so that we only get the”_1.fastq.gz” files.</p>
<p>[ ]: for r1 in data/*_1.fastq.gz</p>
<p>do</p>
<p>echo $r1</p>
<p>done</p>
<p>Great! Now, the only problem here is that we’re going to want to use both the ”_1.fastq.gz” and the</p>
<p>”_2.fastq.gz” files in our mapping. We can get around this by removing the “data/” directory and</p>
<p>”_1.fastq.gz” suffix from the filename to give us our sample name.</p>
<p>sample=$(basename $r1) sample=${sample/_1.fastq.gz/}</p>
<p>This will get the base filename (e.g.&nbsp;“MT1_1.fastq.gz”) and replace the ”_1.fastq.gz” at the end of</p>
<p>the filename we stored as “r1” with nothing.</p>
<p>We’ve added a little descriptive message so that when we run our loop we know which iteration it’s</p>
<p>on and what it’s doing. Let’s try adding our HISAT2 mapping command.</p>
<p>4010 Running commands on multiple samples</p>
<p>Note: we assume that the HISAT2 index has already been generated as that’s a command you’ll only</p>
<p>need to run once.</p>
<p>[ ]: for r1 in data/*_1.fastq.gz</p>
<p>do</p>
<p>sample=$(basename $r1)</p>
<p>sample=${sample/_1.fastq.gz/}</p>
<p>echo “Processing sample:”$sample</p>
<p>echo “Mapping sample:”$sample</p>
<p>hisat2 –max-intronlen 10000 -x data/PccAS_v3_hisat2.idx \</p>
<p>-1 “data/${sample}_1.fastq.gz” -2 “data/${sample}_2.fastq.gz” -S “data/</p>
<p>→${sample}.sam”</p>
<p>done</p>
<p>Notice that because we’re using a variable as part of the filename, we need to write the filename in</p>
<p>double quotes.</p>
<p>data/${sample}_1.fastq.gz</p>
<p>Now let’s add in our samtools commands.</p>
<p>[ ]: for r1 in data/*_1.fastq.gz</p>
<p>do</p>
<p>sample=$(basename $r1)</p>
<p>sample=${sample/_1.fastq.gz/}</p>
<p>echo “Processing sample:”$sample</p>
<p>echo “Mapping sample:”$sample</p>
<p>hisat2 –max-intronlen 10000 -x data/PccAS_v3_hisat2.idx \</p>
<p>-1 “data/${sample}_1.fastq.gz” -2 “data/${sample}_2.fastq.gz” -S “data/</p>
<p>→${sample}.sam”</p>
<p>echo “Converting SAM to BAM:”$sample</p>
<p>samtools view -b -o “data/${sample}.bam” “data/${sample}.sam”</p>
<p>echo “Sorting BAM:”$sample</p>
<p>samtools sort -o “data/${sample}_sorted.bam” “data/${sample}.bam”</p>
<p>echo “Indexing BAM:”$sample</p>
<p>samtools index “data/${sample}_sorted.bam”</p>
<p>done</p>
<p>4110 Running commands on multiple samples 10.1 Taking a closer look at the SBP genome mapping bash script</p>
<p>Finally, we don’t really want to keep intermediate SAM and unsorted BAM files if we don’t have to.</p>
<p>They just take up precious space. So, let’s make our samtools command a one-liner, passing the</p>
<p>stdout from one command to another.</p>
<p>[ ]: for r1 in data/*_1.fastq.gz</p>
<p>do</p>
<p>sample=$(basename $r1)</p>
<p>sample=${sample/_1.fastq.gz/}</p>
<p>echo “Processing sample:”$sample</p>
<p>hisat2 –max-intronlen 10000 -x data/PccAS_v3_hisat2.idx \</p>
<p>-1 “data/${sample}_1.fastq.gz” -2 “data/${sample}_2.fastq.gz” \</p>
<p>| samtools view -b - \</p>
<p>| samtools sort -o “data/${sample}_sorted.bam” - \</p>
<p>&amp;&amp; samtools index “data/${sample}_sorted.bam”</p>
<p>done</p>
<p>You could also have used this approach for transcript quantification with Kallisto, assuming you had</p>
<p>already generated the Kallisto index.</p>
<p>[ ]: for r1 in data/*_1.fastq.gz</p>
<p>do</p>
<p>sample=$(basename $r1)</p>
<p>sample=${sample/_1.fastq.gz/}</p>
<p>echo “Quantifying transcripts for sample:”$sample</p>
<p>kallisto quant -i data/PccAS_v3_kallisto -o “data/${sample}” -b 100 \</p>
<p>“data/${sample}_1.fastq.gz” “data/${sample}_2.fastq.gz”</p>
<p>done</p>
<p>10.1 Taking a closer look at the SBP genome mapping bash script</p>
<p>In the genome mapping section of this tutorial, we mentioned that the sorted genome alignments</p>
<p>had been provided for the three SBP samples and that to generate them, we had run a bash script.</p>
<p>To take a look at the script you can run:</p>
<p>less data/map_SBP_samples.sh</p>
<p>The script contains commands to run the mapping, converting, sorting and indexing for all of the</p>
<p>SBP samples. There’s a great introduction to bash scripting and loops in your Unix module.</p>
<p>First, the bash script looks for all files in the data directory which start with “SBP” and end with</p>
<p>”_1.fastq.gz”. This is so that we get one filename per sample.</p>
<p>data/SBP*_1.fastq.gz</p>
<p>4210 Running commands on multiple samples 10.1 Taking a closer look at the SBP genome mapping bash script</p>
<p>To run the commands for each of our SBP samples: SBP1, SBP2 and SBP3, the script uses a for</p>
<p>loop. Often, scripts like these can take a while to run and it can be difficult to track what’s going on</p>
<p>if there is limited or indistinguisable output. Here, we are printing the file path that gets returned</p>
<p>by our search.</p>
<p>for r1 in data/SBP*_1.fastq.gz</p>
<p>do</p>
<p>echo $r1</p>
<p>done</p>
<p>This will print out:</p>
<p>SBP1_1.fastq.gz</p>
<p>SBP2_1.fastq.gz</p>
<p>SBP3_1.fastq.gz</p>
<p>Next, the script removes parts of the filename to get the name of the sample it belongs to. It does this</p>
<p>becuase both FASTQ files (r1 and r2) are required to align each sample. There are many different</p>
<p>ways to do this. This is one example:</p>
<p>for r1 in data/SBP*_1.fastq.gz</p>
<p>do</p>
<p>echo $r1</p>
<p>sample=$(basename $r1)</p>
<p>sample=${sample/_1.fastq.gz/}</p>
<p>echo “Processing sample:”$sample</p>
<p>done</p>
<p>Which will print out:</p>
<p>Processing sample: SBP1</p>
<p>Processing sample: SBP2</p>
<p>Processing sample: SBP3</p>
<p>Finally, the script runs the single command we were using above for the sample:</p>
<p>hisat2 –max-intronlen 10000 -x data/PccAS_v3_hisat2.idx \</p>
<p>-1 “data/${sample}_1.fastq.gz” -2 “data/${sample}_2.fastq.gz” \</p>
<p>| samtools view -b - \</p>
<p>| samtools sort -o “data/${sample}_sorted.bam” - \</p>
<p>&amp;&amp; samtools index “data/${sample}_sorted.bam”</p>
<p>Note, when it extracted the sample name in the commands above, it stored it as a variable $sample.</p>
<p>It can then use the $sample variable to create a dynamic command which will run for any of the</p>
<p>samples.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>This work is licensed under a Creative Commons Attribution 4.0 International License. Reuse is encouraged with acknowledgement</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Manual – NGS Bioinformatics course</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">NGS Bioinformatics course</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-modules" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Modules</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-modules">    
        <li>
    <a class="dropdown-item" href="../../course_modules/Module1/module1.html">
 <span class="dropdown-text">File formats</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course_modules/Module2/module2.html">
 <span class="dropdown-text">Reads alignment</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course_modules/Module3/module3.html">
 <span class="dropdown-text">Variant calling</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course_modules/Module4/module4.html">
 <span class="dropdown-text">Structural Variation Calling</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course_modules/Module5/module5.html">
 <span class="dropdown-text">Genome assembly</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#section" id="toc-section" class="nav-link active" data-scroll-target="#section"></a>
  <ul class="collapse">
  <li><a href="#table-of-contents" id="toc-table-of-contents" class="nav-link" data-scroll-target="#table-of-contents">Table of Contents</a></li>
  <li><a href="#introduction-and-learning-outcomes" id="toc-introduction-and-learning-outcomes" class="nav-link" data-scroll-target="#introduction-and-learning-outcomes">1. Introduction and Learning Outcomes</a></li>
  <li><a href="#dna-variations-definitions-and-types" id="toc-dna-variations-definitions-and-types" class="nav-link" data-scroll-target="#dna-variations-definitions-and-types">2. DNA Variations: Definitions and Types</a></li>
  <li><a href="#practical-applications-of-variant-calling" id="toc-practical-applications-of-variant-calling" class="nav-link" data-scroll-target="#practical-applications-of-variant-calling">3. Practical Applications of Variant Calling</a></li>
  <li><a href="#variant-calling-basics" id="toc-variant-calling-basics" class="nav-link" data-scroll-target="#variant-calling-basics">4. Variant Calling Basics</a></li>
  <li><a href="#steps-in-variant-detection" id="toc-steps-in-variant-detection" class="nav-link" data-scroll-target="#steps-in-variant-detection">5. Steps in Variant Detection</a></li>
  <li><a href="#common-sources-of-error" id="toc-common-sources-of-error" class="nav-link" data-scroll-target="#common-sources-of-error">6. Common Sources of Error</a></li>
  <li><a href="#advanced-topics-in-variant-calling" id="toc-advanced-topics-in-variant-calling" class="nav-link" data-scroll-target="#advanced-topics-in-variant-calling">7. Advanced Topics in Variant Calling</a></li>
  <li><a href="#assessing-and-benchmarking-variant-calls" id="toc-assessing-and-benchmarking-variant-calls" class="nav-link" data-scroll-target="#assessing-and-benchmarking-variant-calls">8. Assessing and Benchmarking Variant Calls</a></li>
  <li><a href="#functional-annotation-and-variant-consequences" id="toc-functional-annotation-and-variant-consequences" class="nav-link" data-scroll-target="#functional-annotation-and-variant-consequences">9. Functional Annotation and Variant Consequences</a></li>
  <li><a href="#population-level-variant-data" id="toc-population-level-variant-data" class="nav-link" data-scroll-target="#population-level-variant-data">10. Population-Level Variant Data</a></li>
  <li><a href="#references-and-additional-resources" id="toc-references-and-additional-resources" class="nav-link" data-scroll-target="#references-and-additional-resources">11. References and Additional Resources</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Manual</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="section" class="level2">
<h2 class="anchored" data-anchor-id="section"></h2>
<section id="table-of-contents" class="level3">
<h3 class="anchored" data-anchor-id="table-of-contents">Table of Contents</h3>
<ol type="1">
<li><p>Introduction and Learning Outcomes</p></li>
<li><p>DNA Variations: Definitions and Types</p></li>
<li><p>Practical Applications of Variant Calling</p></li>
<li><p>Variant Calling Basics</p></li>
<li><p>Steps in Variant Detection</p></li>
<li><p>Common Sources of Error</p></li>
<li><p>Advanced Topics in Variant Calling</p></li>
<li><p>Assessing and Benchmarking Variant Calls</p></li>
<li><p>Functional Annotation and Variant Consequences</p></li>
<li><p>Population-Level Variant Data</p></li>
<li><p>References and Additional Resources</p></li>
</ol>
</section>
<section id="introduction-and-learning-outcomes" class="level3">
<h3 class="anchored" data-anchor-id="introduction-and-learning-outcomes">1. Introduction and Learning Outcomes</h3>
<p>By the end of this course, you should be able to:</p>
<ul>
<li><p>Understand various types of genomic variations and how they arise.</p></li>
<li><p>Describe how variant calls are generated from raw sequencing data.</p></li>
<li><p>Assess variant quality and visualize variants using tools such as IGV.</p></li>
<li><p>Perform basic variant annotation and interpret biological consequences.</p></li>
</ul>
</section>
<section id="dna-variations-definitions-and-types" class="level3">
<h3 class="anchored" data-anchor-id="dna-variations-definitions-and-types">2. DNA Variations: Definitions and Types</h3>
<p>Mutations refer to any alteration in the DNA base sequence and can be broadly classified into germline and somatic mutations. Germline mutations occur in the egg or sperm cells and are heritable, meaning they can be passed on to subsequent generations. In contrast, somatic mutations arise in non-germline tissues and do not get inherited by offspring. When examining the types of genomic variations, it is essential to differentiate between large-scale and small-scale changes. Large-scale variations include chromosomal gains or losses (such as aneuploidies), various forms of translocations (for instance, reciprocal and Robertsonian), and copy number variants (CNVs), which are duplications or deletions typically ranging from approximately 1 kilobase to several megabases—collectively accounting for roughly 12% of the human genome. Structural variants (SVs), including insertions, inversions, translocations, and tandem duplications larger than 50 base pairs, also fall into this category. On the other hand, small-scale variations involve more subtle changes such as single nucleotide variants (SNVs), which are simple base substitutions (for example, A→C or G→T), indels that represent small insertions or deletions (less than 50 base pairs), multinucleotide polymorphisms (MNPs) which involve multiple adjacent base substitutions, and microsatellites or short tandem repeats (STRs). STRs are characterized by the repetition of small motifs of 2–6 base pairs—like the “GATA” sequence repeated 7 versus 8 times—which are inherently more variable. Notably, while single nucleotide polymorphisms (SNPs) are usually biallelic with a relatively low mutation rate (around 10^-8 per base pair per generation), STRs are multiallelic with higher mutation rates, making their ancestral states more challenging to infer.</p>
<p>To summarise:</p>
<p><strong>Mutation / Variation</strong>: Any change in the DNA base sequence.</p>
<p><strong>Germline mutation</strong>: Heritable variation present in egg or sperm cells.</p>
<p><strong>Somatic mutation</strong>: Variation in non-germline tissues; not passed to offspring.</p>
<p><strong>Copy number variants (CNVs)</strong>: Duplications or deletions ranging from ~1 kb to many Mb, accounting for roughly 12% of the human genome.</p>
<p><strong>Structural Variants (SVs)</strong>: Insertions, inversions, translocations, tandem duplications, etc. (often &gt;50 bp).</p>
<p><strong>Single Nucleotide Variants (SNVs)</strong>: Base substitutions (A→C, G→T, etc.).</p>
<p><strong>Indels</strong>: Small insertions or deletions (&lt;50 bp).</p>
<p><strong>Multinucleotide Polymorphisms (MNPs):</strong> Multiple adjacent base substitutions.</p>
<p><strong>Microsatellites / STRs</strong>: Short-tandem repeats of 2–6 bp repeated multiple times (e.g., “GATA” repeated 7 vs 8 times).</p>
</section>
<section id="practical-applications-of-variant-calling" class="level3">
<h3 class="anchored" data-anchor-id="practical-applications-of-variant-calling">3. Practical Applications of Variant Calling</h3>
<p>Cataloging biological diversity is fundamental for understanding population genetics and exploring evolutionary trends, while disease diagnosis leverages the identification of pathogenic mutations in clinical settings. In addition, deciphering genotype-phenotype associations plays a crucial role in locating variants that underlie specific traits or diseases, thereby facilitating pharmacogenomics where drug choice and dosage are tailored based on individual genotypes. DNA forensics employs STR profiling to aid law enforcement and personal identification, and comprehensive population genetics studies help infer demographic history. Finally, marker-assisted selection is widely used in agriculture and breeding programs to improve crop and livestock traits efficiently.</p>
</section>
<section id="variant-calling-basics" class="level3">
<h3 class="anchored" data-anchor-id="variant-calling-basics">4. Variant Calling Basics</h3>
<p>In a diploid genome, each human cell contains two copies of every chromosome, which means that each locus on the genome has two alleles. The combination of these alleles is referred to as the genotype, and examples include homozygous genotypes like “RR” and “AA” or heterozygous combinations such as “RA.” When these allele combinations are resolved into phase, meaning the specific arrangement on each individual chromosome is known, they form what is called a haplotype.</p>
<p>In the context of variant calling, the term “reference allele” (or “Ref”) refers to the allele that appears in the reference genome, whereas the “alternate allele” (or “Alt”) is the observed variant in the sequenced sample. For a diploid organism, the possible genotypes based on these alleles can be represented as RR (0/0), RA (0/1), or AA (1/1).</p>
<p>The Variant Call Format, or VCF, is a widely adopted tab-delimited text format designed for storing gene sequence variations. The format includes key fields such as CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO, FORMAT, and additional sample-specific columns. Notably, the VCF format captures details such as the depth (DP), which is the total number of sequencing reads covering a variant site, and the allelic depth (AD), which provides coverage information for each allele.</p>
<p>Several tools are available for variant calling. <strong>BCFtools</strong> and <strong>samtools</strong> are frequently used for identifying single nucleotide variants (SNPs) and small insertions or deletions (indels) from alignment data. For more advanced analyses, tools like <strong>GATK’s</strong> <strong>HaplotypeCaller</strong> leverage local re-assembly techniques to improve the accuracy of indel calling. Additionally, other tools such as <strong>FreeBayes, Platypus</strong>, and <strong>DeepVariant</strong> contribute to variant calling efforts by offering alternative methodologies and algorithms suited to various data types and experimental designs.</p>
</section>
<section id="steps-in-variant-detection" class="level3">
<h3 class="anchored" data-anchor-id="steps-in-variant-detection">5. Steps in Variant Detection</h3>
<p>The process begins by generating sequencing data, which consists of raw reads produced by sequencing platforms such as Illumina. These reads are subjected to rigorous quality control, including trimming of adapters and filtering out low-quality bases, before being aligned or mapped to a reference genome. Once aligned, a pileup is generated to summarize the number of reads supporting each base at every position, which then informs the variant calling step—determining the genotype probabilities at each locus. Subsequent filtering addresses factors such as base quality, where Phred scores indicate the confidence in each base call, mapping quality that reflects the accuracy of the read’s placement within the genome, and established depth thresholds to ensure sufficient coverage. Variant calling itself can be approached naïvely, using simple allele-frequency thresholds (for example, calling a heterozygote if roughly 50% of reads show a particular base), or through more sophisticated statistical methods that incorporate base and mapping error rates, prior allele frequencies, and other variables to compute a posterior probability for each potential genotype.</p>
</section>
<section id="common-sources-of-error" class="level3">
<h3 class="anchored" data-anchor-id="common-sources-of-error">6. Common Sources of Error</h3>
<p>Several common sources of error must be considered during variant calling. Homopolymers and repetitive regions, characterized by long runs of identical bases, frequently cause systematic sequencing and mapping errors. Strand bias, where a variant appears exclusively on forward or reverse sequencing reads, often signals technical artefacts rather than genuine biological variants. Incorrect alignments, particularly near insertions or deletions (indels), may lead to false-positive single nucleotide polymorphisms (SNPs). Additionally, extremely high sequencing coverage can indicate repetitive elements or duplicated genomic regions, complicating accurate variant calling. Differences between RNA-seq and DNA-seq data, such as splice junctions and RNA editing events, may also produce apparent variants that do not reflect underlying genomic DNA sequence changes. Finally, variability in experimental conditions can result in non-reproducible calls, emphasizing the importance of validating and replicating findings to ensure reliability.</p>
</section>
<section id="advanced-topics-in-variant-calling" class="level3">
<h3 class="anchored" data-anchor-id="advanced-topics-in-variant-calling">7. Advanced Topics in Variant Calling</h3>
<p><strong>Somatic variant calling</strong> specifically aims to identify genetic variants present in tumor cells by comparing sequences from tumor samples against matched normal tissues. The primary objective is detecting mutations that may drive cancer progression. Because tumors are heterogeneous, subclonal variants—mutations present in only a subset of cells—often exhibit widely varying allele fractions, complicating their detection and interpretation. Specialized bioinformatics pipelines such as Mutect2 and Strelka2 have been developed to address these complexities and accurately distinguish true somatic mutations from background noise.</p>
<p><strong>Indel calling presents unique challenges</strong>, notably due to elevated sequencing error rates in regions such as microsatellites and homopolymers, where accurate base calling is particularly difficult. Additionally, indels can be represented in multiple valid ways by different alignment tools, leading to inconsistencies in their annotation and interpretation. As a result, complex indel regions often suffer from low reproducibility, with significant discrepancies observed across different variant callers. Users are encouraged to validate indel calls rigorously, especially in clinical or sensitive research contexts.</p>
<p><strong>Emerging approaches in variant calling</strong> are addressing these limitations. Local de novo assembly methods, implemented in tools like GATK’s HaplotypeCaller, Scalpel, and Octopus, reconstruct local genomic haplotypes directly from sequencing reads, helping resolve complex variants more effectively. Additionally, newer methods employ variation graphs—data structures that represent multiple known variants simultaneously—to improve alignment accuracy and variant calling performance, particularly in regions of high genetic complexity or variability. These innovative approaches promise to significantly enhance the accuracy and comprehensiveness of genomic analyses moving forward.</p>
</section>
<section id="assessing-and-benchmarking-variant-calls" class="level3">
<h3 class="anchored" data-anchor-id="assessing-and-benchmarking-variant-calls">8. Assessing and Benchmarking Variant Calls</h3>
<p>The <strong>transition/transversion (Ts/Tv) ratio</strong> is a critical metric used to assess the quality of variant calls. Transitions (Ts)—base substitutions within purines (A↔︎G) or pyrimidines (C↔︎T)—occur more frequently than transversions (Tv), substitutions between purines and pyrimidines. For high-quality SNP datasets in humans, a Ts/Tv ratio of approximately 2 to 3 is typically expected; deviations from this range can indicate underlying errors in variant calling.</p>
<p>Another key consideration is the concept of a <strong>callable genome</strong>, as certain regions of the genome are inherently difficult to analyze due to repetitive sequences, structural complexities, or extreme GC content. Not all genomic regions are equally accessible or “callable,” and thus it is beneficial to utilize established benchmark sets, such as the Genome in a Bottle project, which define high-confidence genomic regions suitable for accurate variant detection and performance assessment.</p>
<p>When evaluating variant-calling performance, metrics such as <strong>precision and recall</strong> become essential. Precision represents the proportion of called variants that are correct (true positives), while recall, also known as sensitivity, measures the proportion of true variants correctly identified. To accurately compute these metrics, benchmarking tools like hap.py or vcfeval are routinely employed, allowing researchers to systematically assess and optimize variant-calling workflows for reliability and accuracy.</p>
</section>
<section id="functional-annotation-and-variant-consequences" class="level3">
<h3 class="anchored" data-anchor-id="functional-annotation-and-variant-consequences">9. Functional Annotation and Variant Consequences</h3>
<p>Functional annotation of genetic variants is an essential step in understanding their potential biological impacts. Annotation tools such as <strong>BCFtools/csq</strong>, <strong>Ensembl Variant Effect Predictor (VEP)</strong>, and <strong>ANNOVAR</strong> are commonly utilized to systematically determine the genomic context of variants, categorizing them as coding, intronic, untranslated region (UTR), or intergenic. These tools further predict the functional consequences of variants, distinguishing between synonymous changes, which do not alter the amino acid sequence, and non-synonymous or missense mutations, which result in amino acid substitutions. More severe mutations include nonsense variants, which introduce premature stop codons, and frameshift variants, which disrupt the reading frame of the protein. Variant pathogenicity is often classified into categories such as pathogenic, likely pathogenic, benign, likely benign, or variants of uncertain significance (VUS). These classifications integrate population frequency data, computational prediction models, family-based segregation analyses, and results from functional assays to provide meaningful insights into the clinical or biological relevance of each variant.</p>
</section>
<section id="population-level-variant-data" class="level3">
<h3 class="anchored" data-anchor-id="population-level-variant-data">10. Population-Level Variant Data</h3>
<p>Population-level variant datasets provide critical resources for interpreting genetic variation in a global context. The <strong>1000 Genomes Project</strong>, for instance, encompasses genomic data from over 2,500 individuals representing 26 distinct populations worldwide, with an average sequencing coverage of approximately 7–8X. This extensive collection offers researchers a comprehensive snapshot of human genetic diversity, aiding studies in population genetics, evolutionary biology, and clinical genomics.</p>
<p>Complementary to the 1000 Genomes Project, resources like <strong>HapMap</strong>, <strong>HGDP-CEPH</strong>, and <strong>gnomAD</strong> further enrich our understanding of global genetic variation. The International HapMap Project, although now archived, was an early effort aimed at cataloging common single nucleotide polymorphisms (SNPs) across diverse human populations. The HGDP-CEPH panel provides valuable genomic data from a broad array of worldwide populations, offering insights into human evolutionary history and population structure. The Genome Aggregation Database (gnomAD) expands upon these earlier efforts by compiling allele frequency data from tens of thousands of sequenced individuals, greatly enhancing our ability to interpret genetic variants, understand their functional significance, and accurately determine their frequencies across different populations.</p>
</section>
<section id="references-and-additional-resources" class="level3">
<h3 class="anchored" data-anchor-id="references-and-additional-resources">11. References and Additional Resources</h3>
<p>Olson, N.D., et al.&nbsp;(2023) Nature Reviews Genetics 24:464–483.</p>
<p>The 1000 Genomes Project Consortium. (2015) Nature 526:68–74.</p>
<p>Cann, H.M., et al.&nbsp;(2002) Science 296:261–262. (HGDP-CEPH)</p>
<p>Ensembl Variation documentation: https://www.ensembl.org/info/docs/variation/index.html</p>
<p>BCFtools: <a href="https://github.com/samtools/bcftools" class="uri">https://github.com/samtools/bcftools</a></p>
<p>VEP (Variant Effect Predictor): <a href="https://github.com/willmclaren/ensembl-vep" class="uri">https://github.com/willmclaren/ensembl-vep</a></p>
<p>gnomAD: <a href="https://gnomad.broadinstitute.org/about" class="uri">https://gnomad.broadinstitute.org/about</a></p>
<p>For course-related inquiries, contact: qasim.ayub@monash.edu</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>This work is licensed under a Creative Commons Attribution 4.0 International License. Reuse is encouraged with acknowledgement</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>